---
title: "HW7_Lian_Jiayi"
author: "Jiayi Lian"
date: "October 12, 2019"
output: pdf_document
---

```{r setup, include=FALSE}
library(parallel)
library(tidyr)
library(dplyr)
```



## P2
a)
Because generated random sample is fake random sample. It is generated by fixed algorithm. To generate different random sample, we need a new seed.
```{r}
# b) Use Boostrap to estimate beta
## data mungo
url_sensory<-"http://www2.isye.gatech.edu/~jeffwu/wuhamadabook/data/Sensory.dat"
Sensory <-read.table(url_sensory, header=F, skip=1, fill=T, stringsAsFactors = F)
Sen_2 <- Sensory[-1, ]
Sen_2_a <- Sen_2 %>% filter(V1 %in% 1:10) %>%
                    rename(Item=V1, V1=V2, V2=V3, V3=V4, V4=V5, V5=V6)
Sen_2_b <- Sen_2 %>% filter(!(V1 %in% 1:10)) %>%
                    mutate(Item=rep(as.character(1:10), each=2)) %>%
                    mutate(V1=as.numeric(V1)) %>%
                    select(c(Item, V1:V5)) 
Sen_final <- Sen_2_a %>% full_join(Sen_2_b) 
y=c(Sen_final[,2],Sen_final[,3],Sen_final[,4],Sen_final[,5],Sen_final[,6])
operator<-c(rep(1,30),rep(2,30),rep(3,30),rep(4,30),rep(5,30))
sensory<-data.frame(y=y,operator=operator)
## boostrap
boost_times<-100
set.seed(992)
beta<-matrix(rep(0,2*boost_times),100,2)
time_original<-system.time(for (i in 1:boost_times) {
  bootdata=sensory[sample(nrow(sensory), size = nrow(sensory), replace = TRUE),]
  beta[i,]= coef(summary(lm(y~operator, data = bootdata)))[,1]
})

# parallel
## Create a cluster via makeCluster
cl <- makeCluster(8)
time_parallel<-system.time(for (i in 1:boost_times) {
  bootdata=sensory[sample(nrow(sensory), size = nrow(sensory), replace = TRUE),]
  beta[i,]= coef(summary(lm(y~operator, data = bootdata)))[,1]
})
## Stop the cluster
stopCluster(cl)
## table
table<-rbind(time_original,time_parallel)[,1:3]
table
```

We can see that parallel can help us increase the efficiency of computing.

## P3
```{r}
# a) newton method with apply fun
target_fun<-function(x)
  {
  return(3^x-sin(x)+cos(5*x))
}
## There are 4 roots, which are -4.9, -3.9, -3.5, -2.8
## Interval [-6,-1.8] can cover all roots and extend -1/+1 to either end.
v<-seq(-6,-1.8,length.out = 1000)
dif<-function(x)
{
  return(log(3)*3^x-cos(x)-5*sin(5*x))
}
newton<-function(x)
{
  x0 = x
  path=0
  y=3^x0-sin(x0)+cos(5*x0)
  i=0
  while (abs(y)>1e-6 & !is.na(y)) {
    if(i>1000)
    {
      print("Out of the interval")
      break
    }
    x_new=x0-y/dif(x0)
    y=3^x_new-sin(x_new)+cos(5*x_new)
    x0=x_new
    path=x_new
    i=i+1
  }
  return(path)
}


time_original<-system.time(
{root1<-sapply(v,newton)}
)

# b) parallel
## Create a cluster via makeCluster
cl <- makeCluster(8)
time_parallel<-system.time({root2<-sapply(v,newton)})
## Stop the cluster
stopCluster(cl)
## table of time
table<-rbind(time_original,time_parallel)[,1:3]
table
## show roots
### Since these roots are numeric, for a single root, there are several rows. I just pick some rows out.
cbind(General=root1,paralell=root2)[seq(1,1000,20),]
```

## P4
a)
I have a question about how to include knowledge of true value into stopping rule. Should I add some command like "abs(theta0-true_theta0)>tollerance" ?
```{r}
## b)
cl <- makeCluster(8)

collect_data<-matrix(rep(0,5000),nrow = 1000, ncol = 5)
tollerance<-1e-9
m=100 
alpha=1e-7
x=rep(1:10,10)
theta <- as.matrix(c(1,2),nrow=2)
X <- cbind(1,rep(1:10,10))
h <- X%*%theta+rnorm(100,0,0.2)

for (i in 1:1000) {
  theta0=3*runif(1)
  theta1=3*runif(1)
  collect_data[i,1]=theta0
  collect_data[i,2]=theta1
  theta0_old=0
  theta1_old=0
  Z=0
  while (abs(theta0-theta0_old)>tollerance && abs(theta1-theta1_old)>tollerance && Z<5*10^6) {
    theta0_old=theta0
    theta1_old=theta1
    Z=Z+1
    theta0=theta0-alpha*sum(theta0+theta1*x-h)/m
    theta1=theta1-alpha*sum((theta0+theta1*x-h)*x)/m
  }
  collect_data[i,3]=theta0
  collect_data[i,4]=theta1
  collect_data[i,5]=Z
}

stopCluster(cl)
colnames(collect_data)<-c("Beta0_Ori","Beta1_Ori","Beta0","Beta1","Iteration")
# show 1st 10 iterations' results
head(collect_data)
# How many iterations have stopped within 5000000 steps
sum(collect_data[,5]<5*10^6)
```
